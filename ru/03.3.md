# 3.3 Как Go работает с web

В предыдущем разделе мы научились, как использовать пакет "net/http" чтобы создать простой web сервер. Принципы работы те же, что мы обсуждали в первом разделе этой главы .

## Основные понятия

Request:  запрос данных клиентом, содержащий GET, POST, Cookie и URL.

Response: ответные данные от сервера к клиентам.

Conn: соединения между клиентами и серверами.

Handler:  логическая обработка запроса и генерация ответа.

## Пакет http, принцип работы.

Следующий рисунок показывает последовательность операций выпоняемых веб-сервером.

![](images/3.3.http.png?raw=true)

3.9 Последовательность операций http

1. Создание сокета, прослушивание порта в ожидание клиентов.
2. Принятие запросов от клиентов.
3. Обработка запроса, чтение заголовка HTTP (header). Если запрос использует метод POST, то данные извлекаются из тела сообщения и передаются обработчику. В итоге сокет возвращает клиенту ответ с данными.

Как только мы узнаем ответы на три следующих вопроса, нам будет легко разобраться, как Go работает с web.

- Как мы слушаем порт?
- Как мы принимаем запросы клиентов?
- Как мы выделяем обработчики?

В предыдущем разделе мы видели, что Go использует `ListenAndServe` выполняющий следующие шаги: инициализирует объект "server", вызывает `net.Listen("tcp", addr)` для настройки слушателя TCP и слушет определенный адрес и порт.

Давайте взглянем на исходный код пакета `http`.

    //Build version go1.1.2.
    	func (srv *Server) Serve(l net.Listener) error {
    		defer l.Close()
    		var tempDelay time.Duration // how long to sleep on accept failure
    		for {
    			rw, e := l.Accept()
    			if e != nil {
    				if ne, ok := e.(net.Error); ok && ne.Temporary() {
    					if tempDelay == 0 {
    						tempDelay = 5 * time.Millisecond
    					} else {
    						tempDelay *= 2
    					}
    					if max := 1 * time.Second; tempDelay > max {
    						tempDelay = max
    					}
    					log.Printf("http: Accept error: %v; retrying in %v", e, tempDelay)
    					time.Sleep(tempDelay)
    					continue
    				}
    				return e
    			}
    			tempDelay = 0
    			c, err := srv.newConn(rw)
    			if err != nil {
    				continue
    			}
    			go c.serve()
    		}
    	}

Как мы принимаем запросы клиентов после того как мы начинаем слушать порт? В исходном коде, мы можем видеть, что `srv.Serve(net.Listener)` вызывается для обработки клиентских запросов. В теле функции есть цикл `for{}`, он принимает запрос, создает новое соединение `srv.newConn()`, затем запускает новый goroutine (горутина), передавая данные запроса на горутину `go c.serve()` Это пример, как Go поддерживает "многопоточность", где каждая горутина "goroutine" является независимой.

Как мы используем специальные функции для обработки запросов? Первое, `conn` разберает запрос `c.ReadRequest()` затем получает соответствующий обработчик:  `handler := c.server.Handler` который является вторым аргуметом при вызове функции `ListenAndServe`. Но т.к. при вызове `ListenAndServe` мы передали `nil` то Go использеут штатный обработчик: `handler = DefaultServeMux`. Что делает  `DefaultServeMux` ? Это переменная маршрутизатор, которая вызывает функцию обработчик для определенных URL. Мы передали этот URL когда использовали функцию `http.HandleFunc("/", sayhelloName)`.
Мы используем эту функцию, чтобы создать правило маршрутизатора для пути "/". Если URL является "/" маршрутизатор вызовет функцию "sayhelloName"

Детализация последовательности выполняемых работ:

![](images/3.3.illustrator.png?raw=true)

3.10 Последовательность операций обрабатывания запроса HTTP

Я думаю теперь вы знаете, как работет web-сервер на Go.

## Links

- [Directory](preface.md)
- Previous section: [Build a simple web server](03.2.md)
- Next section: [Get into http package](03.4.md)






